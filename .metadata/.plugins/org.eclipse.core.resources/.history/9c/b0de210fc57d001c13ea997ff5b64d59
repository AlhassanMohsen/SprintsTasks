/*
 * SPI.c
 *
 *  Created on: Jan 25, 2022
 *      Author: Alhassan Mohsen
 */

#include "SPI_prv.h"
#include "SPIConfig.h"
#include "SPI_interface.h"


uint8_t gu8_SPIState= SPI_NOT_INITIALIZED; /// This flag is used to detect when user is trying to use the Peripheral before initialization or in wrong mode

uint8_t SPI_u8Init(SPIMode_t u8SPIMode)
{
	uint8_t u8ErrorState = SPI_OK;


	/*
	 * Set the transmittion Clock of the SPI as configured by the SPI_CLK_RATE Configuration
	 */
#if SPI_CLK_RATE == SPI_CPU_4
	CLR_BIT(SPCR_REG,SPR0_BIT);
	CLR_BIT(SPCR_REG,SPR1_BIT);
	CLR_BIT(SPSR_REG,SPI2X_BIT);
#elif SPI_CLK_RATE == SPI_CPU_16
	SET_BIT(SPCR_REG,SPR0_BIT);
	CLR_BIT(SPCR_REG,SPR1_BIT);
	CLR_BIT(SPSR_REG,SPI2X_BIT);
#elif SPI_CLK_RATE == SPI_CPU_64
	CLR_BIT(SPCR_REG,SPR0_BIT);
	SET_BIT(SPCR_REG,SPR1_BIT);
	CLR_BIT(SPSR_REG,SPI2X_BIT);
#elif SPI_CLK_RATE == SPI_CPU_128
	SET_BIT(SPCR_REG,SPR0_BIT);
	SET_BIT(SPCR_REG,SPR1_BIT);
	CLR_BIT(SPSR_REG,SPI2X_BIT);
#elif SPI_CLK_RATE == SPI_CPU_2
	CLR_BIT(SPCR_REG,SPR0_BIT);
	CLR_BIT(SPCR_REG,SPR1_BIT);
	SET_BIT(SPSR_REG,SPI2X_BIT);
#elif SPI_CLK_RATE == SPI_CPU_8
	SET_BIT(SPCR_REG,SPR0_BIT);
	CLR_BIT(SPCR_REG,SPR1_BIT);
	SET_BIT(SPSR_REG,SPI2X_BIT);
#elif SPI_CLK_RATE == SPI_CPU_32
	CLR_BIT(SPCR_REG,SPR0_BIT);
	SET_BIT(SPCR_REG,SPR1_BIT);
	SET_BIT(SPSR_REG,SPI2X_BIT);
#else
	u8ErrorState = SPI_WRONG_CLK_CFG;
#endif

	/*
	 * Set the DATA sampling mode of the SPI as configured by the SPI_DATA_MODE configuration in the configuration file
	 */
#if SPI_DATA_MODE == SPI_SAMPLE_LEADING_RISING
	CLR_BIT(SPCR_REG,CPHA_BIT);
	CLR_BIT(SPCR_REG,CPOL_BIT);
#elif SPI_DATA_MODE == SPI_SAMPLE_TRAILING_FALLING
	SET_BIT(SPCR_REG,CPHA_BIT);
	CLR_BIT(SPCR_REG,CPOL_BIT);
#elif SPI_DATA_MODE == SPI_SAMPLE_LEADING_FALLING
	CLR_BIT(SPCR_REG,CPHA_BIT);
	SET_BIT(SPCR_REG,CPOL_BIT);
#elif SPI_DATA_MODE == SPI_SAMPLE_TRAILING_RISING
	SET_BIT(SPCR_REG,CPHA_BIT);
	SET_BIT(SPCR_REG,CPOL_BIT);
#else
	u8ErrorState = SPI_WRONG_SAMPLE_MODE_CFG;
#endif

	/*
	 * Setting the Data bits transmitting order as configured by the SPI_DATA_ORDER configuration in the configuration file
	 */
#if SPI_DATA_ORDER == SPI_LSB_FIRST
	SET_BIT(SPCR_REG,DORD_BIT);
#elif SPI_DATA_ORDER == SPI_MSB_FIRST
	CLR_BIT(SPCR_REG,DORD_BIT);
#else
	u8ErrorState = SPI_WRONG_DATA_ORDER_CFG;
#endif

	/*Set the SPI Mode and Configure the SPI PINS */
	if (u8SPIMode == SPI_MASTER)
	{
		//Set the SPI mode to master
		SET_BIT(SPCR_REG,MSTR_BIT);
		//Configure the MOSI pin as output
		SET_BIT(DDRB_REG,DDB5_BIT);
		//Configure the Slave Select pin as output
		SET_BIT(DDRB_REG,DDB4_BIT);
		SET_BIT(PORTB_REG,DDB4_BIT);
		//Configure the SCK pin as output
		SET_BIT(DDRB_REG,DDB7_BIT);

	}else if (u8SPIMode == SPI_SLAVE)
	{
		//Set the SPI mode to Slave
		CLR_BIT(SPCR_REG,MSTR_BIT);
		//Configure the MISO pin as output
		SET_BIT(DDRB_REG,DDB6_BIT);
	}else
	{
		u8ErrorState = SPI_WRONG_MODE;
	}

	/*Check if no error occurred in the previous stages then Enable the SPI with the Written Configurations*/
	if (u8ErrorState==SPI_OK)
	{
		SET_BIT(SPCR_REG,SPE_BIT);
		/*Change the state of the SPI to initialized as MASTER/SLAVE indicating that it is initialized and in this mode*/
		gu8_SPIState = u8SPIMode;
	}
	else
	{
		//if not do nothing
	}

	return u8ErrorState;
}

uint8_t SPI_u8SendByte(uint8_t u8Data)
{
	uint8_t u8ErrorState = SPI_OK;

	if (gu8_SPIState!=SPI_NOT_INITIALIZED)//check first if the SPI is initialized
	{
		CLR_BIT(PORTB_REG,DDB4_BIT);
		//Load the Data to the SPI data Register to initiate the transmission
		SPDR_REG = u8Data;
		//Wait until the Transmission is complete
		while (!GET_BIT(SPSR_REG,SPIF_BIT));
		SET_BIT(PORTB_REG,DDB4_BIT);
	}else
	{
		u8ErrorState = SPI_INITIALIZATION_ERROR;
	}
	return u8ErrorState;
}

uint8_t SPI_u8ReceiveByte(uint8_t* u8Data)
{
	uint8_t u8ErrorState = SPI_OK;


	if (gu8_SPIState!=SPI_NOT_INITIALIZED)//check first if the SPI is initialized
	{
		if (u8Data!=NULL)//Then Check if the pointer is not pointing to a NULL
		{
			//Wait until the Reception is complete
			while (!GET_BIT(SPSR_REG,SPIF_BIT));
			//Load the SPI data Register to the place the pointer holding its address
			*u8Data = SPDR_REG;
		}else
		{
			u8ErrorState = SPI_NULL_INPUT;
		}

	}else
	{
		u8ErrorState = SPI_INITIALIZATION_ERROR;
	}
	return u8ErrorState;
}




