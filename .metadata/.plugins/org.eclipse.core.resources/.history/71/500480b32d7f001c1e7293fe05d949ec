/*
 * I2C.c
 *
 *  Created on: Jan 27, 2022
 *      Author: Alhassan Mohsen
 */

#include "I2C_interface.h"
#include "I2C_prv.h"

static volatile uint8_t gu8_I2CState;
static volatile uint8_t gu8_I2CMode;
static volatile uint8_t gu8_I2CData[255]={0};
static volatile uint8_t gu8_I2CLastByte= 0;
static volatile uint8_t gu8_I2CRepeatedStart= 0;

uint8_t I2C_u8GetStatus(void)
{
	return TWSR_REG & I2C_PRESCALAR_MASK;
}

uint8_t I2C_u8SendByte(uint8_t u8SlaveAddress, uint8_t u8Data)
{
	uint8_t u8ErrorState = I2C_OK;
	uint8_t I2CStatus;

	if (u8SlaveAddress<I2C_ADDRESSES_LIMIT)
	{//check that the address is less than 120 because the addresses from 120 to 127 are reserved for future purposes

		while (I2CStatus != I2C_MT_DATA_TRANSMITTED_ACK && I2CStatus != I2C_MT_DATA_TRANSMITTED_NACK)
		{//do the following until the status of the I2C states that the transmission is done successfully

			//Send the Start Condition
			SET_BIT(TWCR_REG,TWSTA_BIT);
			//Wait until it is sent
			while (!GET_BIT(TWCR_REG,TWINT_BIT));
			//Get the state of the I2C
			I2CStatus= I2C_u8GetStatus();

			switch(I2CStatus)// check which state it is
			{
			case I2C_MT_START_TRANSMITTED:
				//if it is state that the start condition is successfully sent then load the slave address in the data register and set the mode to write
				TWDR_REG = u8SlaveAddress;
				CLR_BIT(TWDR_REG,7);
				// Clear the interrupt flag to start the next action by the peripheral
				ASSIGN_HIGH_NIB(TWCR_REG,I2C_CLR_INTERRUPT_FLAG);
				break;
			case I2C_MT_SLAVE_WRITE_TRANSMITTED_ACK:
				//if it is state that the SLA/W is successfully sent then load the data to be sent in the data register
				TWDR_REG= u8Data;
				// Clear the interrupt flag to start the next action by the peripheral
				ASSIGN_HIGH_NIB(TWCR_REG,I2C_CLR_INTERRUPT_FLAG);
				break;
			case I2C_MT_SLAVE_WRITE_TRANSMITTED_NACK:
				//if it is state that the SLA/W is successfully sent then load the data to be sent in the data register
				TWDR_REG= u8Data;
				// Clear the interrupt flag to start the next action by the peripheral
				ASSIGN_HIGH_NIB(TWCR_REG,I2C_CLR_INTERRUPT_FLAG);
				break;
			default:
				u8ErrorState = I2C_WRONG_STATUS;
			}
		}

	}else
	{
		u8ErrorState = I2C_WRONG_ADDRESS;
	}
	return u8ErrorState;
}

uint8_t I2C_u8SendRepeatedStart(void)
{
	uint8_t u8ErrorState = I2C_OK;
	uint8_t u8I2CState= I2C_u8GetStatus();

	if (u8I2CState==I2C_MT_DATA_TRANSMITTED_ACK || u8I2CState==I2C_MT_DATA_TRANSMITTED_NACK)
	{

	}


	return u8ErrorState;
}
